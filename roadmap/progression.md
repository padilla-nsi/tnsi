# Progressions - Terminale NSI

## Années scolaire : 34 semaines

## Progression

1. Récursivité
1. Modularité
1. Programmation objet
1. Mise au point de programmes
1. Programmation fonctionnelle
1. Listes chaînées
1. Piles et files
1. Arbres binaires
1. Arbres binaires de recherche
1. Autres structures arborescentes
1. **Graphes**
1. **Parcours en profondeur et en largeur**
1. Diviser pour régner
1. **Programmation dynamique**
1. **Recherche textuelle**
1. **Calculabilité**
1. Modèle relationnel
1. Bases de données relationnelles
1. Requêtes SQL et mise à jour
1. **Système de Gestion de Base de Donnée**
1. Circuits intégrés
1. Gestion des processus et des ressources
1. Protocoles de routage
1. **Sécurisation des communications**

---

20 semaine avant
7
6
5
2


- [Progressions - Terminale NSI](#progressions---terminale-nsi)
  - [Années scolaire : 34 semaines](#années-scolaire--34-semaines)
  - [Progression](#progression)
    - [Récursivité](#récursivité)
    - [Modularité](#modularité)
    - [Programmation objet](#programmation-objet)
    - [Mise au point de programmes](#mise-au-point-de-programmes)
    - [**Période 1** (7 semaines, 02/09..23/10)](#période-1-7-semaines-02092310)
    - [**Période 2** (6 semaines : 08/11..18/12)](#période-2-6-semaines--08111812)
    - [**Période 3** (5 semaines : 03/01..05/02)](#période-3-5-semaines--03010502)
    - [**Période 4** (7 semaines : 21/02..09/04)](#période-4-7-semaines--21020904)
    - [**Période 5** (9 semaines : 25/04..07/07)](#période-5-9-semaines--25040707)
- [Détail](#détail)

Avant les épreuves terminales (semaine 36 .. semaine 9)

### Récursivité

**Langages**
</br> Récursivité.

* Écrire un programme récursif.
* Analyser le fonctionnement d’un
programme récursif.

> Des exemples relevant de
domaines variés sont à privilégier.

### Modularité

**Langages**
</br> Modularité.

* Utiliser des API (Application
Programming Interface) ou des
bibliothèques.
* Exploiter leur documentation.
* Créer des modules simples et
les documenter.

### Programmation objet

**Structures de données**
</br> Vocabulaire de la
programmation objet :
classes, attributs,
méthodes, objets.

* Écrire la définition d’une classe.
* Accéder aux attributs et
méthodes d’une classe.

> On n’aborde pas ici tous les
aspects de la programmation
objet comme le polymorphisme et
l’héritage.

### Mise au point de programmes

**Langages**
</br> Mise au point des
programmes.
</br> Gestion des bugs.

* Dans la pratique de la
programmation, savoir répondre
aux causes typiques de bugs :
problèmes liés au typage, effets
de bord non désirés,
débordements dans les
tableaux, instruction
conditionnelle non exhaustive,
choix des inégalités,
comparaisons et calculs entre
flottants, mauvais nommage des
variables, etc.

> On prolonge le travail entrepris en
classe de première sur l’utilisation
de la spécification, des assertions,
de la documentation des
programmes et de la construction
de jeux de tests.
</br> Les élèves apprennent
progressivement à anticiper leurs
erreurs.

**Structures de données**
</br> Structures de données,
interface et
implémentation.

* Spécifier une structure de
données par son interface.
* Distinguer interface et
implémentation.
* Écrire plusieurs implémentations
d’une même structure de
données.

> L’abstraction des structures de
données est introduite après
plusieurs implémentations d’une
structure simple comme la file
(avec un tableau ou avec deux
piles).

**Structures de données**
</br> Listes, piles, files :
structures linéaires.
</br> Dictionnaires, index et
clé.

* Distinguer des structures par le
jeu des méthodes qui les
caractérisent.
* Choisir une structure de
données adaptée à la situation à
modéliser.
* Distinguer la recherche d’une
valeur dans une liste et dans un
dictionnaire.

> On distingue les modes FIFO (first

in first out) et LIFO (last in first
out) des piles et des files.

**Structures de données**
</br> Arbres : structures
hiérarchiques.
</br> Arbres binaires :
nœuds, racines,
feuilles,
sous-arbres gauches,
sous-arbres droits.

* Identifier des situations
nécessitant une structure de
données arborescente.
* Évaluer quelques mesures des
arbres binaires (taille,
encadrement de la hauteur,
etc.).

> On fait le lien avec la rubrique
« *algorithmique* ».

**Bases de données**
</br>Modèle relationnel :
relation, attribut,
domaine, clef primaire,
clef étrangère, schéma
relationnel.

* Identifier les concepts définissant
le modèle relationnel.

> Ces concepts permettent
d’exprimer les contraintes
d’intégrité (domaine, relation et
référence).

**Bases de données**
</br>Base de données
relationnelle.

* Savoir distinguer la structure
d’une base de données de son
contenu.
* Repérer des anomalies dans le
schéma d’une base de données.

> La structure est un ensemble de
schémas relationnels qui
respecte les contraintes du
modèle relationnel.
</br> Les anomalies peuvent être des
redondances de données ou des
anomalies d’insertion, de
suppression, de mise à jour.
</br> On privilégie la manipulation de
données nombreuses et
réalistes.

**Bases de données**
</br>Langage SQL :
requêtes d’interrogation
et de mise à jour d’une
base de données.

* Identifier les composants d’une
requête.
* Construire des requêtes
d’interrogation à l’aide des
clauses du langage SQL :
SELECT, FROM, WHERE, JOIN.
* Construire des requêtes
d’insertion et de mise à jour à
l’aide de : UPDATE, INSERT,
DELETE.

> On peut utiliser DISTINCT,
ORDER BY ou les fonctions
d’agrégation sans utiliser les
clauses GROUP BY et HAVING.

**Machines** </br>
Composants intégrés
d’un système sur puce.

* Identifier les principaux
composants sur un schéma de
circuit et les avantages de leur
intégration en termes de vitesse
et de consommation.

> Le circuit d’un téléphone peut être
pris comme un exemple :
microprocesseurs, mémoires
locales, interfaces radio et filaires,
gestion d’énergie, contrôleurs
vidéo, accélérateur graphique,
réseaux sur puce, etc.

**Machines**
</br>Gestion des processus
et des ressources par
un système
d’exploitation.

* Décrire la création d’un
processus, l’ordonnancement de
plusieurs processus par le
système.
Mettre en évidence le risque de
l’interblocage (*deadlock*).

> À l’aide d’outils standard, il s’agit
d’observer les processus actifs ou
en attente sur une machine.
</br> Une présentation débranchée de
l’interblocage peut être proposée.

**Machines**
</br> Protocoles de routage.

* Identifier, suivant le protocole de 
routage utilisé, la route
empruntée par un paquet.

> En mode débranché, les tables de
routage étant données, on se
réfère au nombre de sauts
(protocole RIP) ou au coût des
routes (protocole OSPF).
</br> Le lien avec les algorithmes de
recherche de chemin sur un
graphe est mis en évidence.

**Algorithmique**
</br> Algorithmes sur les
arbres binaires et sur
les arbres binaires de
recherche.

* Calculer la taille et la hauteur
d’un arbre.
* Parcourir un arbre de différentes
façons (ordres infixe, préfixe ou
suffixe ; ordre en largeur
d’abord).
* Rechercher une clé dans un
arbre de recherche, insérer une
clé.

> Une structure de données
récursive adaptée est utilisée.
</br> L’exemple des arbres permet
d’illustrer la programmation par
classe.
</br> La recherche dans un arbre de
recherche équilibré est de coût
logarithmique.

**Algorithmique**
</br>Méthode « diviser pour
régner ».

*  Écrire un algorithme utilisant la
méthode « diviser pour régner ».

> La rotation d’une image bitmap
d’un quart de tour avec un coût en
mémoire constant est un bon
exemple.
</br> L’exemple du tri fusion permet
également d’exploiter la
récursivité et d’exhiber un
algorithme de coût en $n \log_2 n$
dans les pires des cas.

---

Après épreuves terminales (semaine 10 .. grand oral)

**Histoire**
</br> Événements clés de l’histoire de l’informatique

* Situer dans le temps les
principaux événements de
l’histoire de l’informatique et
leurs protagonistes.
* Identifier l’évolution des rôles
relatifs des logiciels et des
matériels.

> Ces repères viennent compléter
ceux qui ont été introduits en
première.
</br> Ces repères historiques sont
construits au fur et à mesure de la
présentation des concepts et
techniques.

**Structures de données**
</br> Graphes : structures relationnelles.
</br> Sommets, arcs, arêtes, graphes orientés ou non orientés

* Modéliser des situations sous
forme de graphes.
* Écrire les implémentations
correspondantes d’un graphe :
matrice d’adjacence, liste de
successeurs/de prédécesseurs.
* Passer d’une représentation à
une autre.

> On s’appuie sur des exemples
comme le réseau routier, le
réseau électrique, Internet, les
réseaux sociaux.
</br> Le choix de la représentation
dépend du traitement qu’on veut
mettre en place : on fait le lien
avec la rubrique « *algorithmique* ».

**Bases de données**
</br> Système de gestion de bases de données relationnelles

* Identifier les services rendus par
un système de gestion de bases
de données relationnelles : persistance des données, gestion
des accès concurrents, efficacité
de traitement des requêtes,
sécurisation des accès.

> Il s’agit de comprendre le rôle et
les enjeux des différents
services sans en détailler le
fonctionnement.

**Machines**
</br>Sécurisation des communications

* Décrire les principes de
chiffrement symétrique (clef
partagée) et asymétrique (avec
clef privée/clef publique).
* Décrire l’échange d’une clef
symétrique en utilisant un
protocole asymétrique pour
sécuriser une communication
HTTPS.

> Les protocoles symétriques et
asymétriques peuvent être
illustrés en mode débranché,
éventuellement avec description
d’un chiffrement particulier.
</br> La négociation de la méthode
chiffrement du protocole SSL
(*Secure Sockets Layer*) n’est pas
abordée.

**Langages**
</br> Notions de programme en tant que donnée.
</br>Calculabilité, décidabilité

* Comprendre que tout
programme est aussi une
donnée.
* Comprendre que la calculabilité
ne dépend pas du langage de
programmation utilisé.
* Montrer, sans formalisme
théorique, que le problème de
l’arrêt est indécidable.

> L’utilisation d’un interpréteur ou
d’un compilateur, le
téléchargement de logiciel, le
fonctionnement des systèmes
d’exploitation permettent de
comprendre un programme
comme donnée d’un autre
programme.

**Langages**
</br> Paradigmes de programmation

* Distinguer sur des exemples les
paradigmes impératif,
fonctionnel et objet.
* Choisir le paradigme de
programmation selon le champ
d’application d’un programme.

> Avec un même langage de
programmation, on peut utiliser
des paradigmes différents. Dans
un même programme, on peut
utiliser des paradigmes différents.

**Algorithmique**
</br> Algorithmes sur les graphes.

* Parcourir un graphe en
profondeur d’abord, en largeur
d’abord.
* Repérer la présence d’un cycle
dans un graphe.
* Chercher un chemin dans un
graphe.

> Le parcours d’un labyrinthe et le
routage dans Internet sont des
exemples d’algorithme sur les
graphes.
</br> L’exemple des graphes permet
d’illustrer l’utilisation des classes
en programmation.

**Algorithmique**
</br>Programmation dynamique.

* Utiliser la programmation
dynamique pour écrire un
algorithme.

> Les exemples de l’alignement de
séquences ou du rendu de
monnaie peuvent être présentés.
</br> La discussion sur le coût en
mémoire peut être développée.

**Algorithmique**
</br>Recherche textuelle

* Étudier l’algorithme de Boyer-Moore
pour la recherche d’un motif dans un texte.

> L’intérêt du prétraitement du motif
est mis en avant.
L’étude du coût, difficile, ne peut
être exigée.


---

### **Période 1** (7 semaines, 02/09..23/10)

1. ...
2. ...
    1. ...
    1. ...

---

### **Période 2** (6 semaines : 08/11..18/12)

4. ...

---

### **Période 3** (5 semaines : 03/01..05/02)

* ....

---

### **Période 4** (7 semaines : 21/02..09/04)

7....

---

### **Période 5** (9 semaines : 25/04..07/07)

9. ...

---

# Détail
